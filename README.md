### 📄 개요
**********************
<img src="https://github.com/TrinityFForce/4Go8Go/assets/54929479/76bb6080-a4b4-4e68-b24b-59831cd87603" width="35%" height="35%"/><br>
* **프로젝트 이름** : **사고팔고**
* **프로젝트 제작기간** : 2024.03.26 ~ 2024.04.29
* **프로젝트 설명** :
  가치 책정이 어려운 품목들 (예 : 골동품,  예술 작품 등)을 대상으로 한 온라인 마켓 플레이스<br>
### 아키텍쳐
*********************
![image](https://github.com/TrinityFForce/4Go8Go/assets/54929479/f0d9cb31-411b-418c-be25-c78d215d7cd7)

## 🛠️ 사용 기술
**************
## **Back-end**

- WindowOS
- IntelliJ
- Java 17
- Spring Boot 3.2.4
- MySQL 8.0
- Docker 25.0.3
- Redis 7.1.0

## Infra

- AWS ECS (ALB, Fargate)
- AWS ECR
- AWS VPC (Route table, NAT gateway, Internet gateway)
- AWS RDS
- AWS ElastiCache
- AWS EventBridge
- AWS Lambda
- AWS S3
- AWS CDN
- AWS Route 53
- AWS Secrets Manager
- AWS Certificate Manager
- Github Actions
- Elastic Search
- Logstash
- Kibana
- Fluent bit

## Frontend

- React
- node.js 18
- Material UI
- Axios
- Recoil


### 🍀 주요 기술
**************

- **입찰 동시성 제어** - Redis의 싱글 스레드 특성을 활용
- **실시간 입찰가 변동** - SSE를 이용해 실시간 입찰가 변동에 대한 처리
- **서비스 성능 테스트** - Jmeter를 이용해 테스트 진행
- **상품 경매 상테 스케줄러** - EventBridge와 Lambda를 이용해 상품의 경매 상태를 변경
- **CI/CD 환경 구축** - Github Actions를 이용한 CI 테스트 환경 및 Docker를 활용한 CD 파이프라인 구축
- **결제 시스템 구축** - 토스 페이먼츠 API를 이용하여 결제 진행
- **로깅 시스템 구축** - ELK + Fluent bit를 활용한 로깅 시스템 구축

### 📐 와이어 프레임
**************
![image](https://github.com/TrinityFForce/4Go8Go/assets/54929479/9d92f2a0-702a-4ad8-bbbf-f6728b93070f)


### 🗂️ ERD (Entity Relationship Diagram)
**************
![image](https://github.com/TrinityFForce/4Go8Go/assets/54929479/e55b7378-fbb0-48cc-972b-7a3a3ea24186)

## 🗣️기술적 의사결정

---

### **1. SSE**

> 도입 이유
> 

 저희 서비스는 실시간 경매 서비스로서,

 다른 유저의 입찰로 인한 입찰가 변동 이벤트를 실시간으로 처리하고자 하였습니다. 

 이를 효과적으로 수행하기 위해 SSE를 적용하였습니다.

> 효과
> 

경매 상품의 상세 페이지에 접속해있다면 별도의 새로고침 없이, 입찰가 변동을 실시간으로

확인할 수 있게 되었습니다.

### **2. Batch Scheduler**

> 도입 이유
> 

 저희 서비스는 매일 오전 9시에 경매가 시작되고, 오후 6시에 경매가 종료됩니다.

당일 경매 품목들의 상태를 변경하는 작업을 일괄적으로 처리해야할 필요성을 느꼈습니다.

> 효과
> 

 별도의 작업 없이, 경매 시작과 종료시간에 맞춰서 당일 경매 품목들의 상태가 변경되고,

 낙찰정보 또한 DB에 저장 작업이 이루어짐으로서 서비스의 효율성을 높일 수 있었습니다.

### **3. Github Actions**

> 도입 이유
> 

프로젝트를 진행하는 과정에서 코드 수정에 따른 새로운 버전 배포가 자주 일어날 것이라고 예상했습니다. 이에 Github Actions를 통한 CI/CD를 도입하여 코드를 푸시하고, merge할때 테스트를 진행하고, 자동으로 배포되도록 하였습니다.

> 효과
> 

 현재 진행중인 프로젝트에 Github Actions를 통한 CI/CD를 도입함으로써 즉각적으로 배포된

 웹페이지에서 결과물을 확인할 수 있어 즉각적인 대처가 가능해졌으며,

 해당 코드에 대한 구체적인 피드백 또한 빠르게 받아볼 수 있게 되었습니다. 

### **4. Redis**

> 도입 이유
> 

저희 서비스는 실시간 경매 서비스로서,

경매 서비스의 특성상 입찰에 높은 트래픽이 발생할 것이라고 예상하였습니다.

이에 따라 입찰 과정의 높은 트래픽을 처리하고자 입찰 성공/실패의 판단을 캐시에서

판단하도록 Redis를 사용하였습니다.

> 효과
> 

 상품 조회와 입찰의 응답속도가 개선되었고, 입찰과정에서의 DB부하가 감소하였으며,

 Redis의 싱글 스레드의 특성을 활용하여 입찰의 동시성 문제 또한 해결하였습니다. 

### **5. ECS (Fargate)**

> **ECS** 도입 이유
> 

저희 서비스는 실시간 경매 서비스로서,

경매가 시작되면 서버에 많은 트래픽이 발생할 것이라고 예상하였습니다.

이에 따라 ECS의 장점인 CloudWatch, ELB, IAM들과 연동하고자 ECS를 선택하였습니다.

> **Fargate** 도입 이유
> 

ECS managed auto scailing이 등장하면서, EC2인스턴스의 관리가 비교적 쉬워지긴 하였으나,

여전히 신경써줘야 하는 상황이 발생한다는 점을 파악했고, 

Fargate를 사용하면 task만 정의한다면 serverless의 특성으로 인프라 영역을 관리하지 않고

바로 애플리케이션을 실행할 수 있다는 장점이 있다는것을 파악했습니다.

그리고 EC2에 비해 Fargate의 단일비용이 더 높지만, EC2가 리소스 예약율을 높게 유지하는게

힘들기에 실질적으로 Fargate가 더 저렴하다는 점을 파악했습니다. 

워크로드가 변칙적이어서 오토스케일링이 자주 일어날수록, EC2의 리소스가 낭비될것이라고

예상하여 Fargate를 도입하였습니다.

물론 Fargate는 GPU를 사용할 수 없고, Swap memory를 사용할 수 없다는 단점도 인지하였으나,

현재 프로젝트에는 영향이 없을 것이라고 판단하였습니다.

### **6. CDN**

> 도입 이유
> 

경매 상품을 등록할때 S3를 통해 이미지를 함께 등록할 수 있도록 하여

상품의 이미지도 함께 확인할 수 있도록 구현하였습니다.

트래픽이 몰릴경우 매번 S3에서 이미지를 직접 추출해내는 방식대신, CloudFront 네트워크에

캐싱해 놓은 데이터를 추출하여 S3 저장소에 대한 자체적인 부하를 줄이고, 로드 속도 또한

개선할 수 있다고 판단하였습니다.

### **7. 결제 (토스 페이먼츠)**

> 도입 이유
> 

낙찰된 상품을 결제하는 기능을 위해 알아보던중에 토스 페이먼츠 API를 선택하였습니다.

API 명세도 굉장히 자세히 나와있었고, 프론트엔드에 대한 지식이 많이 부족한 상태였는데,

프론트엔드의 코드 예시도 제공해주고, 테스트 결제의 경우 실질적으로 결제가 이루어지지

않는점이 좋아서 토스 페이먼츠 API를 선택하게 되었습니다.

### **8. ELK + Fluent Bit**

> 도입 이유
> 

ECS Fargate 환경에서 서비스 모니터링을 강화하고,

웹 서버 시스템 로그에 대한 접근성을 향상시킬 필요가 있다고 판단했습니다.

이를 위해 웹 서버 컨테이너에 Firelens(Fluent bit)를 사이드 카 패턴으로 붙여

로그를 효율적으로 수집하고, Elasticsearch와 Kibana를 통해 시각화하였습니다.

그리고 잧은 요청이 들어오는 상품 검색 엔진을 보다 빠르고 정밀하게 구현하기 위해

logstash를 통해 RDB의 데이터를 Elasticsearch와 동기화 한 뒤,

Elasticsearch의 뛰어난 검색 및 집계 기능을 도입하였습니다.

> 효과
> 

기존에는 로그 수집 및 관리가 번거롭고 복잡했으나,

도입 이후 로그 데이터의 수집 및 분석이 효율화되어 서비스 운영 효율이 향상되었습니다.

그리고 Elasticsearch의 검색 엔진을 통해 보다 빠르고 정밀한 검색 기능을 구현함으로서,

서비스 품질 향상과 사용자 만족도 향상의 효과를 얻었습니다.

### **9. Https**

> 도입 이유
> 

경매 서비스의 특성상 금전적인 정보가 오고 가기에 보안적인 측면에서의 강화가 필요하다고

판단했습니다. 이에 따라 서비스에 SSL인증서를 통해 보안을 강화하는 https를 적용하였습니다.

## 🛠 트러블슈팅

---

### 1. Scheduler 개선 (EventBridge, Lambda)

> **발생**
> 

```
메인 서버가 오토 스케일링 되어 늘어날경우,
여러개의 서버에서 스케줄링이 이루어지는 문제가 발생했습니다.
```

> **해결방안**
> 
- EventBridge와 Lambda를 사용하여 Serverless로 경매 상태를 변경하도록 변경하였습니다.

![image](https://github.com/TrinityFForce/4Go8Go/assets/54929479/9da4b49b-8700-4140-9aa0-d7c9d8fbaffa)


### 2. 조회, 입찰 캐시 적용 (응답속도 개선, 동시성 문제 해결)

> **발생**
> 

```
경매 서비스의 특성상 입찰에 높은 트래픽이 몰릴것으로 예상했습니다.
이에 따라 느린 응답시간과 동시성 문제가 발생했습니다.
```

![image](https://github.com/TrinityFForce/4Go8Go/assets/54929479/d7f693f0-201a-4621-ba4b-7ad50688ca20)


> **해결과정**
> 
1. 입찰에 캐싱을 적용하여 1차적으로 캐시정보를 통해 입찰 성공 여부를 판단하도록 변경.
    - Redis의 싱글 스레드의 특성을 활용하여 동시성 문제 해결
2. 조회에도 캐싱을 적용하여 조회 응답 속도 개선.
3. 조회 캐싱 전략을 수정하여 TTL(5초)

입찰에 캐싱을 적용하여 입찰 성공시에만 DB에 반영하도록 변경하였습니다.

조회에도 캐싱을 적용하여 입찰, 상품 수정, 등 상품 정보에 변경이 발생하면 캐시무효화가

발생하도록 구현하였는데, 높은 입찰 트래픽으로 인해 캐싱의 효과가 제대로 나타나지 않을것

이라고 예상했습니다. 따라서 조회 캐시에는 TTL을 적용하여 조회 캐싱 효과를 높였습니다.

Redis의 싱글 스레드의 특성을 활용하여 입찰의 동시성 문제 또한 해결하였습니다. 

![image](https://github.com/TrinityFForce/4Go8Go/assets/54929479/3f309e05-886a-4ff1-85f9-fdc1e0ee76b5)


> **결과**
> 

![image](https://github.com/TrinityFForce/4Go8Go/assets/54929479/d9033557-6a34-404c-8eb7-975073c6777b)


캐싱을 적용하여

조회의 응답시간은 기존대비 63.4% 감소하였고,

입찰의 응답시간은 기존대비 43.5% 감소하였으며,

평균 응답시간은 기존대비 49.3% 감소하였습니다.

### 3. 별도의 SSE 서버 구축

> **발생**
> 

```
SSE의 특성상 connection이 유지되기에, 유저가 아무런 행동을 하지않고 접속만 하고있어도
메인 서버의 오토 스케일링이 문제가 된다고 판단했습니다.
```

> **해결방안**
> 
- 별도의 SSE 서버를 구축하여 메인 서버의 부하를 분산하고,
- 원활한 오토 스케일링이 되도록 개선하였습니다.

![image](https://github.com/TrinityFForce/4Go8Go/assets/54929479/7adfa162-dd11-432d-99f4-3313fa18c7f8)


### 4. 사용자 경험 개선 (Latency hiding)

> **발생**
> 

```
상품을 등록하는 과정의 응답속도를 개선하는 과정에서, 이미지 업로드 시간의 비중이 높은것을
확인했습니다.
```

![image](https://github.com/TrinityFForce/4Go8Go/assets/54929479/505be9f4-b962-4f0b-ae4c-38cd61dc4190)


> **해결과정**
> 
1. 상품 등록 과정에서 이미지를 추가한경우 이미지를 즉시 업로드 하도록 변경.
2. 사용자가 부가적인 정보를 기입하는 과정동안 이미지 업로드 완료.
3. 사용자는 정보를 기입하고 상품 등록이 바로 진행되는 것으로 느낌.

이미지를 추가하면 즉시 업로드 하여 사용자가 정보를 기입하는 과정에 이미지 업로드시간을

숨김으로써 사용자 경험을 개선하였습니다.

> **결과**
> 

![image](https://github.com/TrinityFForce/4Go8Go/assets/54929479/7354d4dd-7f84-474d-acb5-daf8d73fcdde)


Latency hiding을 적용하여

상품등록의 응답시간은 기존대비 90.8% 감소하였습니다.

### 5. [유저테스트] 입찰가격 오버플로우 문제

> **발생**
> 

```
유저 테스트의 피드백에서 입찰가격이 2147483647원까지 입찰이 가능하고,
이후에는 오버플로우가 발생하여 입찰가격 비교 로직이 수행되지 않음을 확인하였습니다.
```

![image](https://github.com/TrinityFForce/4Go8Go/assets/54929479/7156fff9-ab5c-4e32-b123-24a7828d516d)


> **해결과정**
> 

가격 필드의 형식을 변경하여도 오버플로우 문제는 해결되지않고,

21억이 넘는 입찰의 발생이 현실적으로 불가능하다고 판단하여

**입찰 상한 가격을 추가하여 해결하였습니다.**

### 6. [유저테스트] 시작입찰가 문제

> **발생**
> 

```
유저 테스트의 피드백에서 입찰횟수가 0회인 상품에 대해 첫번째 입찰을 할 경우, 시작 입찰가로
입찰을 시도해도 실패하는것을 확인하였습니다.
```

> **해결과정**
> 

입찰 성공/실패 판단 로직을 작성할때, 이 부분에 대해서 고려를 하지 않아 발생한 문제였습니다.

입찰 로직을 수정하여 기존의 시작입찰가 + 입찰단위 이상만 입찰 가능한 로직에서

입찰 내역이 존재하지 않는 상품의 경우 시작입찰가 이상만 입찰이 가능하도록 수정하였습니다.

### 7. [유저테스트] 추천 게시물 노출 시차 문제

> **발생**
> 

```
메인 페이지에 접속하면, 접속 시간대에 따라 다른 상품들을 노출해주도록 구현하였습니다.
 - 자정 ~ 오전9시 : 당일 경매예정인 상품
 - 오전9시 ~ 오후6시 : 당일 경매중인 상품
 - 오후6시 ~ 자정 : 당일 경매종료된 상품

해당 로직은 서버의 시간을 기준으로 LocalDate로 동작하도록 하였는데,
배포하는 과정에서 현지와의 시차가 발생하여 제대로 동작하지 않음을 확인하였습니다.
```

> **해결과정**
> 

현지와의 시차가 9시간 차이나는것을 확인하였고,

 해당 로직에 시차를 반영해주어 해결하였습니다.
